// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title GameSession
 * @notice FHE-based card draw randomness for FHEIGHT single player
 * @dev Contract only manages random index generation and reveal operations.
 *      Game logic (board, hand, mana) is handled server-side.
 *
 * FLOW:
 * 1. createSinglePlayerGame() - Generates 40 FHE.rand() values
 * 2. getDrawHandles() - Client gets encrypted handles
 * 3. Client SDK.publicDecrypt() decrypts from KMS
 * 4. revealDrawBatch() - Client sends clear indices + proof
 * 5. Server getVerifiedDrawOrder() reads verified indices
 */

// ============ FHE IMPORTS ============
import { FHE, euint8 } from "@fhevm/solidity/lib/FHE.sol";
import { ZamaEthereumConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

contract GameSession is ZamaEthereumConfig {

    // ============ CONSTANTS ============
    uint8 public constant DECK_SIZE = 40;
    uint8 public constant INITIAL_HAND_SIZE = 5;

    // ============ STRUCTS ============
    struct Game {
        address player;
        uint8 currentTurn;
        uint8 revealedCount;
        bool isActive;
        uint256 createdAt;
    }

    // ============ STORAGE ============

    // Games mapping
    mapping(uint256 => Game) public games;

    // Draw indices - encrypted random values (FHE encrypted)
    // IMPORTANT: euint8[40] array type doesn't work with FHE!
    // Must use nested mapping: gameId => index => euint8
    mapping(uint256 => mapping(uint8 => euint8)) private drawIndices;

    // Revealed values - verified clear indices
    mapping(uint256 => uint8[]) public revealedValues;

    // Mock: Which indices are revealed (not needed in production)
    mapping(uint256 => mapping(uint8 => bool)) private isRevealed;

    // ============ EVENTS ============
    event GameCreated(uint256 indexed gameId, address indexed player);
    event TurnIncremented(uint256 indexed gameId, uint8 newTurn);
    event DrawRevealed(uint256 indexed gameId, uint8 count, uint8 totalRevealed);
    event GameEnded(uint256 indexed gameId);

    // ============ MODIFIERS ============
    modifier onlyPlayer(uint256 gameId) {
        require(msg.sender == games[gameId].player, "Not player");
        _;
    }

    modifier gameActive(uint256 gameId) {
        require(games[gameId].isActive, "Game not active");
        _;
    }

    // ============ MAIN FUNCTIONS ============

    /**
     * @notice Create new single player game
     * @dev Generates 40 encrypted random indices using FHE.randEuint8()
     * @param gameId Unique game ID generated by server
     */
    function createSinglePlayerGame(uint256 gameId) external {
        require(games[gameId].player == address(0), "Game exists");

        games[gameId] = Game({
            player: msg.sender,
            currentTurn: 0,
            revealedCount: 0,
            isActive: true,
            createdAt: block.timestamp
        });

        // Generate 40 encrypted random indices (real FHE)
        for (uint8 i = 0; i < DECK_SIZE; i++) {
            euint8 encryptedIndex = FHE.randEuint8();
            // CRITICAL: Allow contract to read this value
            FHE.allowThis(encryptedIndex);
            // Save to storage
            drawIndices[gameId][i] = encryptedIndex;
            // Make publicly decryptable
            FHE.makePubliclyDecryptable(encryptedIndex);
        }

        emit GameCreated(gameId, msg.sender);
    }

    /**
     * @notice Increment turn (must be called before drawing cards)
     * @dev Can only increment if current reveals are completed
     * @param gameId Game ID
     */
    function incrementTurn(uint256 gameId) external onlyPlayer(gameId) gameActive(gameId) {
        Game storage game = games[gameId];

        // Current turn reveals must be completed
        uint8 allowed = getAllowedReveals(gameId);
        require(game.revealedCount == allowed, "Complete reveals first");

        game.currentTurn++;

        emit TurnIncremented(gameId, game.currentTurn);
    }

    /**
     * @notice Batch reveal - birden fazla index'i tek TX'te doğrula
     * @dev Client decrypt sonrası clear indices + proof gönderir
     * @param gameId Game ID
     * @param clearIndices Decrypt edilmiş index değerleri
     * @param abiEncodedClearValues ABI-encoded clear values
     * @param decryptionProof KMS decryption proof
     */
    function revealDrawBatch(
        uint256 gameId,
        uint8[] calldata clearIndices,
        bytes calldata abiEncodedClearValues,
        bytes calldata decryptionProof
    ) external onlyPlayer(gameId) gameActive(gameId) {
        uint8 count = uint8(clearIndices.length);
        uint8 startIdx = games[gameId].revealedCount;

        require(count > 0, "Empty indices");
        require(startIdx + count <= getAllowedReveals(gameId), "Exceeds allowed");
        require(startIdx + count <= DECK_SIZE, "Exceeds deck");

        // Build handle list and verify proof
        _verifyAndReveal(gameId, startIdx, count, clearIndices, abiEncodedClearValues, decryptionProof);

        games[gameId].revealedCount = startIdx + count;
        emit DrawRevealed(gameId, count, startIdx + count);
    }

    /**
     * @notice Internal function to verify proof and store reveals
     */
    function _verifyAndReveal(
        uint256 gameId,
        uint8 startIdx,
        uint8 count,
        uint8[] calldata clearIndices,
        bytes calldata abiEncodedClearValues,
        bytes calldata decryptionProof
    ) internal {
        bytes32[] memory cts = new bytes32[](count);
        for (uint8 i = 0; i < count; i++) {
            cts[i] = FHE.toBytes32(drawIndices[gameId][startIdx + i]);
        }

        // Verify KMS decryption proof - reverts if invalid
        FHE.checkSignatures(cts, abiEncodedClearValues, decryptionProof);

        // Mark as revealed and store values
        for (uint8 i = 0; i < count; i++) {
            isRevealed[gameId][startIdx + i] = true;
            revealedValues[gameId].push(clearIndices[i]);
        }
    }

    /**
     * @notice End the game
     * @param gameId Game ID
     */
    function endGame(uint256 gameId) external onlyPlayer(gameId) {
        games[gameId].isActive = false;
        emit GameEnded(gameId);
    }

    // ============ VIEW FUNCTIONS ============

    /**
     * @notice How many cards can be revealed (based on turn)
     * @dev Turn 0: 5 (initial hand), Turn 1+: 5 + turn
     * @param gameId Game ID
     * @return allowed Total allowed reveal count
     */
    function getAllowedReveals(uint256 gameId) public view returns (uint8) {
        uint8 turn = games[gameId].currentTurn;
        // Turn 0: 5 cards (initial hand)
        // Turn 1: 6 cards (5 + 1)
        // Turn 2: 7 cards (5 + 2)
        // ...
        uint8 allowed = INITIAL_HAND_SIZE + turn;
        return allowed > DECK_SIZE ? DECK_SIZE : allowed;
    }

    /**
     * @notice Get next handles to be decrypted
     * @dev Client sends these handles to SDK.publicDecrypt
     * @param gameId Game ID
     * @param count How many handles requested
     * @return handles Encrypted euint8 handles (as bytes32)
     */
    function getDrawHandles(
        uint256 gameId,
        uint8 count
    ) external view returns (bytes32[] memory handles) {
        Game storage game = games[gameId];
        uint8 start = game.revealedCount;
        uint8 allowed = getAllowedReveals(gameId);

        require(start + count <= allowed, "Exceeds allowed reveals");
        require(start + count <= DECK_SIZE, "Exceeds deck");

        handles = new bytes32[](count);

        // Return FHE encrypted handles as bytes32
        for (uint8 i = 0; i < count; i++) {
            handles[i] = FHE.toBytes32(drawIndices[gameId][start + i]);
        }

        return handles;
    }

    /**
     * @notice Get all verified draw indices
     * @dev Server calls this function to calculate cards
     * @param gameId Game ID
     * @return indices All revealed indices
     */
    function getVerifiedDrawOrder(uint256 gameId) external view returns (uint8[] memory) {
        return revealedValues[gameId];
    }

    /**
     * @notice How many cards have been revealed
     * @param gameId Game ID
     * @return count Revealed count
     */
    function getRevealedCount(uint256 gameId) external view returns (uint8) {
        return games[gameId].revealedCount;
    }

    /**
     * @notice Current turn number
     * @param gameId Game ID
     * @return turn Current turn
     */
    function getCurrentTurn(uint256 gameId) external view returns (uint8) {
        return games[gameId].currentTurn;
    }

    /**
     * @notice Is game active
     * @param gameId Game ID
     * @return active Is game active
     */
    function isGameActive(uint256 gameId) external view returns (bool) {
        return games[gameId].isActive;
    }

    /**
     * @notice Get game information
     * @param gameId Game ID
     * @return player Player address
     * @return currentTurn Current turn
     * @return revealedCount Number of revealed cards
     * @return allowedReveals Number of allowed reveals
     * @return isActive Is game active
     */
    function getGameInfo(uint256 gameId) external view returns (
        address player,
        uint8 currentTurn,
        uint8 revealedCount,
        uint8 allowedReveals,
        bool isActive
    ) {
        Game storage game = games[gameId];
        return (
            game.player,
            game.currentTurn,
            game.revealedCount,
            getAllowedReveals(gameId),
            game.isActive
        );
    }

    /**
     * @notice Has a specific index been revealed (for debug)
     * @param gameId Game ID
     * @param index Index number
     * @return revealed Is revealed
     */
    function isIndexRevealed(uint256 gameId, uint8 index) external view returns (bool) {
        require(index < DECK_SIZE, "Invalid index");
        return isRevealed[gameId][index];
    }
}
